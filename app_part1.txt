"""
Context-Aware FinCommerce Engine - Streamlit Demo UI

A hackathon demo showcasing personalized product recommendations
using semantic search, affordability scoring, and preference matching.
"""

import streamlit as st
import json
from pathlib import Path
from typing import List, Dict, Any, Tuple

# Import backend search function
from search_pipeline import search_products, get_qdrant_client, PRODUCTS_COLLECTION
from interaction_logger import log_interaction

# =============================================================================
# Interaction Hooks
# =============================================================================

def on_product_view(product: Dict[str, Any], query: str = ""):
    """Hook for product view interaction."""
    try:
        user_context = build_user_context()
        log_interaction(
            user_id=user_context["user_id"],
            product_payload=product.get("payload", {}),
            interaction_type="view",
            query=query
        )
    except Exception as e:
        st.warning(f"Failed to log view: {e}")


def on_product_click(product: Dict[str, Any], query: str = ""):
    """Hook for product click interaction."""
    try:
        user_context = build_user_context()
        log_interaction(
            user_id=user_context["user_id"],
            product_payload=product.get("payload", {}),
            interaction_type="click",
            query=query
        )
    except Exception as e:
        st.warning(f"Failed to log click: {e}")


def on_add_to_cart(product: Dict[str, Any], query: str = ""):
    """Hook for add to cart interaction."""
    try:
        user_context = build_user_context()
        log_interaction(
            user_id=user_context["user_id"],
            product_payload=product.get("payload", {}),
            interaction_type="add_to_cart",
            query=query
        )
        st.toast("âœ… Added to cart! (Interaction logged)", icon="ðŸ›’")
    except Exception as e:
        st.warning(f"Failed to log add to cart: {e}")


def on_purchase(product: Dict[str, Any], query: str = ""):
    """Hook for purchase interaction."""
    try:
        user_context = build_user_context()
        log_interaction(
            user_id=user_context["user_id"],
            product_payload=product.get("payload", {}),
            interaction_type="purchase",
            query=query
        )
        st.toast("âœ… Purchase logged! Thank you!", icon="ðŸ’³")
    except Exception as e:
        st.warning(f"Failed to log purchase: {e}")

# =============================================================================
# Configuration
# =============================================================================

st.set_page_config(
    page_title="FinCommerce Engine",
    page_icon="ðŸ›’",
    layout="wide",
    initial_sidebar_state="expanded",
)

# User personas for quick selection
USER_PERSONAS = {
    "Student": {"balance": 500, "credit": 1000, "risk": "Low"},
    "Professional": {"balance": 5000, "credit": 15000, "risk": "Medium"},
    "Executive": {"balance": 20000, "credit": 50000, "risk": "High"},
    "Custom": {"balance": 2500, "credit": 5000, "risk": "Medium"},
}


@st.cache_data(show_spinner=False)
def load_brand_category_options() -> Tuple[List[str], List[str]]:
    """
    Extract distinct brands and categories from the product dataset.
    Filters out numeric or placeholder values.
    """
    # First try to load from Qdrant Cloud
    qdrant_options = _load_brand_category_options_from_qdrant()
    if qdrant_options[0] or qdrant_options[1]:
        return qdrant_options

    data_path = Path(__file__).parent / "data" / "products_payload.json"
    
    try:
        with data_path.open("r", encoding="utf-8") as f:
            products = json.load(f)
    except FileNotFoundError:
        # Fallback if file doesn't exist
        return (
            ["Apple", "Samsung", "Sony", "HP", "Dell", "Nike", "Adidas"],
            ["Electronics", "Clothing", "Footwear", "Home & Kitchen", "Sports"],
        )
    
    def has_digit(value: str) -> bool:
        """Check if string contains digits (likely placeholder/ID)."""
        return any(ch.isdigit() for ch in value)
    
    # Extract unique brands and categories, filtering out invalid entries
    brands = sorted({
        b for b in ((p.get("brand") or "").strip() for p in products)
        if b and not has_digit(b) and len(b) > 1
    })
    
    categories = set()
    for p in products:
        cats = p.get("categories", [])
        if not isinstance(cats, list):
            cats = [cats] if cats else []
        for c in cats:
            c = str(c).strip()
            if c and not has_digit(c) and len(c) > 1:
                categories.add(c)

    categories = sorted(categories)
    
    return brands, categories


@st.cache_data(show_spinner=False)
def _load_brand_category_options_from_qdrant() -> Tuple[List[str], List[str]]:
    """
    Pull distinct brands/categories from Qdrant products collection.
    Falls back to empty lists if Qdrant is unavailable.
    """
    def has_digit(value: str) -> bool:
        return any(ch.isdigit() for ch in value)

    try:
        client = get_qdrant_client()
    except Exception:
        return [], []

    brands: set[str] = set()
    categories: set[str] = set()

    try:
        next_page = None
        while True:
            points, next_page = client.scroll(
                collection_name=PRODUCTS_COLLECTION,
                limit=4000,
                with_payload=True,
                with_vectors=False,
                offset=next_page,
            )

            if not points:
                break

            for p in points:
                payload = p.payload or {}
                brand = (payload.get("brand") or "").strip()
                cats = payload.get("categories", [])
                if not isinstance(cats, list):
                    cats = [cats] if cats else []

                if brand and not has_digit(brand) and len(brand) > 1:
                    brands.add(brand)
                for category in cats:
                    category = str(category).strip()
                    if category and not has_digit(category) and len(category) > 1:
                        categories.add(category)

            if not next_page:
                break

    except Exception:
        return [], []

    return sorted(brands), sorted(categories)


def init_session_state():
    """Initialize session state with default values."""
    defaults = {
        "user_persona": "Professional",
        "available_balance": 5000.0,
        "credit_limit": 15000.0,
        "preferred_brands": [],
        "preferred_categories": [],
        "search_query": "",
        "search_results": [],
        "has_searched": False,
    }
    for key, value in defaults.items():
        if key not in st.session_state:
            st.session_state[key] = value


def build_user_context() -> Dict[str, Any]:
    """Build user context dictionary from session state for backend."""
    return {
        "user_id": f"demo_{st.session_state.user_persona.lower()}",
        "name": f"Demo {st.session_state.user_persona}",
        "available_balance": st.session_state.available_balance,
        "credit_limit": st.session_state.credit_limit,
        "preferred_brands": st.session_state.preferred_brands,
        "preferred_categories": st.session_state.preferred_categories,
        "risk_tolerance": USER_PERSONAS.get(
            st.session_state.user_persona, {}
        ).get("risk", "Medium"),
    }


def render_sidebar():
    """Render sidebar controls for user context configuration."""
    st.sidebar.title("ðŸŽ›ï¸ User Profile")
    st.sidebar.markdown("---")
    
    # Load options from dataset
    brand_options, category_options = load_brand_category_options()
    
    # User persona selector
    persona = st.sidebar.selectbox(
        "ðŸ‘¤ User Type",
        options=list(USER_PERSONAS.keys()),
        index=list(USER_PERSONAS.keys()).index(st.session_state.user_persona),
        help="Select a preset user profile or customize below",
    )
    
    # Update defaults when persona changes
    if persona != st.session_state.user_persona:
        st.session_state.user_persona = persona
        if persona != "Custom":
            preset = USER_PERSONAS[persona]
            st.session_state.available_balance = float(preset["balance"])
            st.session_state.credit_limit = float(preset["credit"])
    
    st.sidebar.markdown("### ðŸ’° Financial Context")
    
    # Available balance slider
    st.session_state.available_balance = st.sidebar.slider(
        "Available Balance ($)",
        min_value=0,
        max_value=50000,
        value=int(st.session_state.available_balance),
        step=100,
        help="Your current available funds",
    )
    
    # Credit limit slider
    st.session_state.credit_limit = st.sidebar.slider(
        "Credit Limit ($)",
        min_value=0,
        max_value=100000,
        value=int(st.session_state.credit_limit),
        step=500,
        help="Your maximum credit allowance",
    )
    
    # Total budget display
    total_budget = st.session_state.available_balance + st.session_state.credit_limit
    st.sidebar.metric("Total Budget", f"${total_budget:,.0f}")
    
    st.sidebar.markdown("### ðŸŽ¯ Preferences")
    
    # Preferred brands multiselect
    st.session_state.preferred_brands = st.sidebar.multiselect(
        "Preferred Brands",
        options=brand_options,
        default=st.session_state.preferred_brands,
        help="Products from these brands will be prioritized",
    )
    
    # Preferred categories multiselect
    st.session_state.preferred_categories = st.sidebar.multiselect(
        "Preferred Categories",
        options=category_options,
        default=st.session_state.preferred_categories,
        help="Products in these categories will be prioritized",
    )
    
    st.sidebar.markdown("---")
    st.sidebar.caption("ðŸ”¬ Powered by Qdrant + SentenceTransformers")


def render_product_card(product: Dict[str, Any], rank: int):
    """Render a single product recommendation card with interaction logging."""
    payload = product.get("payload", {})
    
    # Extract product details with defaults
    name = payload.get("name", "Unknown Product")
    description = payload.get("description", "No description available")
    price = payload.get("price", 0.0)
    brand = payload.get("brand", "Unknown")
    categories = payload.get("categories", ["General"])
    if not isinstance(categories, list):
        categories = [categories] if categories else ["General"]
    category = categories[0] if categories else "General"
    monthly_installment = payload.get("monthly_installment", price / 12)
    in_stock = payload.get("in_stock", True)
    image_url = (payload.get("image_url") or "").strip()
    
    # Extract scores
    final_score = product.get("final_score", 0.0)
    semantic_score = product.get("semantic_score", 0.0)
    affordability_score = product.get("affordability_score", 0.0)
    preference_score = product.get("preference_score", 0.0)
    collaborative_score = product.get("collaborative_score", 0.0)
    popularity_score = product.get("popularity_score", 0.0)
    
    # Get explanations
    explanations = product.get("explanations", [])
    
    # Log view interaction automatically
    on_product_view(product, st.session_state.get("search_query", ""))
    
    # Determine score color
    if final_score >= 0.7:
        score_color = "ðŸŸ¢"
    elif final_score >= 0.5:
        score_color = "ðŸŸ¡"
    else:
        score_color = "ðŸ”´"
    
    # Card container
    with st.container():
        col1, col2, col3 = st.columns([3, 1, 1])
        
        with col1:
            if image_url:
                st.image(image_url, width=220)
            st.markdown(f"### #{rank} {name}")
            st.caption(f"**{brand}** Â· {category}")
        
        with col2:
            st.metric("Price", f"${price:,.2f}")
            st.caption(f"${monthly_installment:,.2f}/mo")
        
        with col3:
            st.metric("Match Score", f"{final_score:.0%}")
            st.caption(f"{score_color} {'In Stock' if in_stock else 'Out of Stock'}")
        
